#Event-Driven Programming

mbed programming is event-driven: it responds to interrupts coming from the hardware, generated by changes in electrical signals or system activity (such as radio communication). Interrupts often lead to the execution of special functions called *event handlers* by the OS. In the context of BLE, event handlers may be triggered quite regularly, for example if a sensor sends a measurement every x seconds, or they may be triggered intermittently.

Event handlers are able to preempt the main program, that is - interrupt its execution in order to do their work; the main program will resume when the interrupting event is fully handled. In the case of BLE, we expect the main program to be a sleep loop (``waitForEvent``), which means that the device will sleep unless it receives an interrupt - programming like this is necessary to take advantage of the low power nature of BLE.

<span style="text-align:center; display:block;">
![events](/GettingStarted/Images/EventHandle.png "An event interrupts the main loop and triggers an action. The interrupt is handled, and the event handler then returns control to main()")
</span>
<span style="background-color:lightblue; color:gray; display:block; height:100%; padding:10px;">An event interrupts the main loop and triggers an action. The interrupt is handled, and the event handler then returns control to main()</span>

The relationship between ``main()`` and event handlers - and especially the decision about which code to move to an event handler and which to leave in ``main()`` - is all about timing. Handler execution time is often determined not by the size of the code but by how many times it must run - for example, how many iterations of a data-processing loop it performs - or by communication with external components such as sensors (also called polling). Communication delays can range from a few microseconds to milliseconds, depending on the sensor involved. Reading an accelerometer can take around a millisecond, and a temperature sensor can take up to a few hundred microseconds. A barometer, on the other hand, can take up to 10 milliseconds to yield a new sensor value. 

If an event, such as a sensor reading, arrives when the program is in ``main()`` (in our case, then, when the device is sleeping), it can trigger an event handler that will wake the device and run immediately. But if it arrives when an event handler is being executed, it may have to wait for the first event to be handled in full. In this scenario, the first event is blocking the execution of the second event. Because event handlers can block each other, they are supposed to execute quickly and return control to ``main()``, to allow the system to remain responsive. In the world of microcontrollers, anything longer than a few dozen microseconds is too long and a millisecond is an eternity. Long-running activities - anything longer than 100 microseconds, such as data processing and sensor communication - should be left in ``main()`` rather than an event handler. This is because ``main()`` can then be interrupted by event handlers, so that the long-running process doesn’t affect the system’s responsiveness. 

In these cases, the event handler is used not to perform functions but rather to enqueue work for the main loop. In the [heart rate demo](http://developer.mbed.org/teams/Bluetooth-Low-Energy/code/BLE_HeartRate/), the work of polling for heart rate data is communicated to the main loop through the variable ``triggerSensorPolling``, which gets set periodically from an event handler called ``periodicCallback()``. 

First, we see the ``triggerSensorPolling`` parameter and ``periodicCallback`` function declarations:

```c
	
	// the parameter triggerSensorPolling begins as FALSE. 
	// It will be set to TRUE in the function periodicCallback
	static volatile bool  triggerSensorPolling = false; 

	[...]
	
	void periodicCallback(void)
	{
		led1 = !led1; /* Do blinky on LED1 while we're waiting for BLE events */

		/* Note that the periodicCallback() executes in interrupt context, 
		* so it is safer to do
		* heavy-weight sensor polling from the main thread. */
		triggerSensorPolling = true; // sets TRUE and returns to main()
	}

```

Next, we tell the program (in ``main()``) to execute ``periodicCallback`` every second:


```c

	int main(void)
	{
		led1 = 1;
		Ticker ticker;
		ticker.attach(periodicCallback, 1); // blink LED every second

```


Finally, we can see where ``triggerSensorPolling`` is used in an infinite loop in ``main()``. Its value (TRUE or FALSE) determines which bit of the code is executed - the heart rate update or ``waitForEvent``:

```c

    // infinite loop
    while (1) {
        // check for trigger from periodicCallback()
        if (triggerSensorPolling && ble.getGapState().connected) { 

	/* if periodicCallback set the value of triggerSensorPolling to TRUE, 
	* we execute the code block that follow. 
	* The first thing it does is reset triggerSensorPolling to FALSE. 
	* Then it executes the interrupt action, which in our case is 
	* simply to change the heart rate */

            triggerSensorPolling = false; 

            // Do blocking calls or whatever is necessary for sensor polling.
            // In our case, we simply update the HRM measurement. 
		
			[...]

        } else { // if nothing came from the sensor, we stay with waitForEvent()
            ble.waitForEvent(); // low power wait for event
        }
    }
```

